/**
 * 分割回文串
 * https://leetcode.cn/problems/palindrome-partitioning/description/
 * 
 * 题意：
 *  给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。
 *  返回 s 所有可能的分割方案。
 * 
 * 示例: 
 *  输入: "aab"
 *  输出: [ ["aa","b"], ["a","a","b"] ]
 * 
 * 
 * 思路:
 *  本题这涉及到两个关键问题：
 *      1.切割问题，有不同的切割方式
 *      2.判断回文
 *  相信这里不同的切割方式可以搞懵很多同学了。
 *  这种题目，想用for循环暴力解法，可能都不那么容易写出来，所以要换一种暴力的方式，就是回溯。
 *  一些同学可能想不清楚 回溯究竟是如何切割字符串呢？
 *  我们来分析一下切割，其实切割问题类似组合问题。
 *  例如对于字符串abcdef：
 *      组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个.....。
 *      切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段.....。
 *  所以切割问题，也可以抽象为一棵树形结构。
 *  递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。
 *  此时可以发现，切割问题的回溯搜索的过程和组合问题的回溯搜索的过程是差不多的。
 * 
 * 
 * 回溯三部曲：
 *  1.递归函数参数
 *      全局变量数组path存放切割后回文的子串，二维数组result存放结果集。 （这两个参数可以放到函数参数里）
 *      本题递归函数参数还需要startIndex，因为切割过的地方，不能重复切割，和组合问题也是保持一致的。
 *      在回溯算法：求组合总和（二） 中我们深入探讨了组合问题什么时候需要startIndex，什么时候不需要startIndex。
 * 
 *  2.递归函数终止条件
 *      从树形结构的图中可以看出：切割线切到了字符串最后面，说明找到了一种切割方法，此时就是本层递归的终止终止条件。
 *      那么在代码里什么是切割线呢？
 *      在处理组合问题的时候，递归参数需要传入startIndex，表示下一轮递归遍历的起始位置，这个startIndex就是切割线。
 * 
 *  3.单层搜索的逻辑
 *      来看看在递归循环，中如何截取子串呢？
 *      在for (int i = startIndex; i < s.size(); i++)循环中，我们 定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的子串。
 *      首先判断这个子串是不是回文，如果是回文，就加入在vector<string> path中，path用来记录切割过的回文子串。
 *      注意切割过的位置，不能重复切割，所以，backtracking(s, i + 1); 传入下一层的起始位置为i + 1。
 * 
 * 
 * 判断回文子串：
 *  最后我们看一下回文子串要如何判断了，判断一个字符串是否是回文。
 *  可以使用双指针法，一个指针从前向后，一个指针从后先前，如果前后指针所指向的元素是相等的，就是回文字符串了。
 * 
 * 
 * 总结：
 *  列出如下几个难点：
 *      切割问题可以抽象为组合问题
 *      如何模拟那些切割线
 *      切割问题中递归如何终止
 *      在递归循环中如何截取子串
 *      如何判断回文
 *  主要卡在了第一个难点上：就是不知道如何切割，甚至知道要用回溯法，也不知道如何用。也就是没有体会到按照求组合问题的套路就可以解决切割。
 *  但接下来如何模拟切割线，如何终止，如何截取子串，其实都不好想，最后判断回文算是最简单的了。
 *  本题还有细节，例如：切割过的地方不能重复切割所以递归函数需要传入i + 1。
 */

// 是否为回文串
const isPalindrome = (s, l, r) => {
    for (let i = l, j = r; i < j; i++, j--) {
        // 不相等就不是回文串
        if (s[i] !== s[j]) {
            return false;
        }
    }

    return true;
}

const partition = function(s) {
    // 二维数组 res 存放结果集
    const res = []
    // 存放切割后回文的子串
    const path = []
    const len = s.length

    backtracking(0);

    return res;

    function backtracking(startIndex) {
        if (startIndex >= len) {
            res.push(Array.from(path));
            return;
        }

        for (let j = startIndex; j < len; j++) {
            // 如果不是回文串则直接跳过
            if (!isPalindrome(s, startIndex, j)) {
                continue
            }

            // 是回文串
            // 获取[startIndex,i]在s中的子串
            path.push(s.substring(startIndex, j + 1));
            // 寻找i+1为起始位置的子串
            backtracking(j + 1);

            // 回溯过程，弹出本次已经存在的子串
            path.pop();
        }
    }
};


// 测试
// [ ["aa","b"], ["a","a","b"] ]
const str = "aab"
console.log(partition(str))