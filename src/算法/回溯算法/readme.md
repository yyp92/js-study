# 回溯算法
回溯算法是纯暴力的搜索

## 分析三部曲
- 递归的参数和返回值
- 确定终止条件
- 单层搜索的逻辑（一般为for循环， 遍历的是集合）


## 递归和回溯相辅相成
- 递归函数的下面就是回溯的过程


## 回溯算法解决的问题
- 组合问题（不强调组合的顺序）
- 切割问题
    - 通常给定一个字符串问有几种切割方式
    - 或者加一下特定的切割条件
- 子集问题
- 排列问题（强调组合顺序）
- 棋盘问题


## 回溯模板（解题步骤）
- backtracking(参数)
- if (终止条件) {收集结果； return}
- for (集合元素) {处理节点；递归函数；回溯操作；} return

## 总结
回溯法抽象为树形结构后，其遍历过程就是：for循环横向遍历，递归纵向遍历，回溯不断调整结果集。


## 是否需要startIndex
- 如果是一个集合来求组合的话，就需要startIndex。
- 如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex。


## 性能
子集问题分析：
- 时间复杂度：$O(n × 2^n)$，因为每一个元素的状态无外乎取与不取，所以时间复杂度为$O(2^n)$，构造每一组子集都需要填进数组，又有需要$O(n)$，最终时间复杂度：$O(n × 2^n)$。
- 空间复杂度：$O(n)$，递归深度为n，所以系统栈所用空间为$O(n)$，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为$O(n)$。

排列问题分析：
- 时间复杂度：$O(n!)$，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ..... 1 = n!。每个叶子节点都会有一个构造全排列填进数组的操作（对应的代码：result.push_back(path)），该操作的复杂度为$O(n)$。所以，最终时间复杂度为：n * n!，简化为$O(n!)$。
- 空间复杂度：$O(n)$，和子集问题同理。

组合问题分析：
- 时间复杂度：$O(n × 2^n)$，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。
- 空间复杂度：$O(n)$，和子集问题同理。

一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括吧！