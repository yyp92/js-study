# 动态规划

## 分类
- 动规基础
    - 爬楼梯
    - 斐波那契
- 背包问题  
    - 01背包 - (有n种物品，每种物品只有一个)
    - 完全背包 - (有n种物品，每种物品有无限个)
    - 多重背包 - (有n种物品，每种物品的个数各不相同)
- 打家劫舍
- 股票问题
- 子序列问题


## 解题五部曲
- 确定dp数组（dp table）以及下标的含义
- 确定递推公式
- dp数组如何初始化
- 确定遍历顺序
- 举例推导dp数组（打印dp数组）


## 背包问题五部曲（解题步骤）

![](../../images/背包问题.png)
### 01背包
- dp[i][j]
    - [0, i] 物品任取放到容量为j的背包

- dp[i][j]
    - 不放物品i -> dp[i-1][j]
    - 放物品i -> dp[i-1][j-weight[i]] + value[i]
- 递推公式：dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])
- 初始化： 要根据物品来初始化，第一列和第一行不一定全是0和1，其他的无所谓什么值都行。
- 循环遍历
    - 如果dp是二维数组，两层的for循环的顺利无所谓
    - 其他维的数组就跟遍历的顺序有关系了

### 01背包（滚动数组篇）
- dp[j]: 容量为j的背包所承受的最大价值为dp[j]。
- 递推公式（就是把二维递推公式的i去掉）：dp[j] = max(dp[j], dp[j-weight[i]] + value[i])。
- 初始化(统一把dp数组初始化为0， 因为max比较，所以应该初始化为最小值)：
    - dp[0] = 0
- 遍历顺序：
    ```js
    // 物品 - 正序
    for (var i = 0; i < 物品数量; i++) {
        // 背包 - 倒叙
        for (var j = bigWeight; j >= weight[i]; j--) {}
    }
    ```

### 01背包问题
- 为什么二维dp数组历的时候不用倒序呢？
    - 因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！
- 再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？
    - 不可以！因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。


### 完全背包问题
- 有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。
- 完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。
- 01背包和完全背包唯一不同就是体现在遍历顺序上，所以本文就不去做动规五部曲了，我们直接针对遍历顺序经行分析！

首先在回顾一下01背包的核心代码
```c
for (int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```
我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。

而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：
```c
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```


### 确定遍历顺序
- 如果求组合数就是外层for循环遍历物品，内层for遍历背包。
- 如果求排列数就是外层for遍历背包，内层for循环遍历物品。


### 背包递推公式
- 问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); ，对应题目如下：
    - 动态规划：[416.分割等和子集](https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html)
    - 动态规划：[1049.最后一块石头的重量 II](https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html)
- 问装满背包有几种方法：dp[j] += dp[j - nums[i]] ，对应题目如下：
    - 动态规划：[494.目标和](https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html)
    - 动态规划：[518.零钱兑换II](https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html)
    - 动态规划：[377.组合总和Ⅳ](https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html)
    - 动态规划：[70.爬楼梯进阶版（完全背包）](https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html)
- 问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); ，对应题目如下：
    - 动态规划：[474.一和零](https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html)
- 问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]); ，对应题目如下：
    - 动态规划：[322.零钱兑换](https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html)
    - 动态规划：[279.完全平方数](https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html)


### 遍历顺序
#### 01背包
在动态规划：[关于01背包问题，你该了解这些！ ](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html)中我们讲解二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。

和动态规划：[关于01背包问题，你该了解这些！（滚动数组） ](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html)中，我们讲解一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。

一维dp数组的背包在遍历顺序上和二维dp数组实现的01背包其实是有很大差异的，大家需要注意！

#### 完全背包
说完01背包，再看看完全背包。

在动态规划：[关于完全背包，你该了解这些！ ](https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html)中，讲解了纯完全背包的一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。

但是仅仅是纯完全背包的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。

**如果求组合数就是外层for循环遍历物品，内层for遍历背包。**

**如果求排列数就是外层for遍历背包，内层for循环遍历物品。**

相关题目如下：
- 求组合数：[动态规划：518.零钱兑换II](https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html)
- 求排列数：
    - [动态规划：377.组合总和Ⅳ](https://mp.weixin.qq.com/s/Iixw0nahJWQgbqVNk8k6gA)
    - [动态规划：70.爬楼梯进阶版（完全背包）](https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html)
- 如果求最小数，那么两层for循环的先后顺序就无所谓了，相关题目如下：
    - 求最小数：
        - [动态规划：322.零钱兑换](https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html)
        - [动态规划：279.完全平方数](https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html)

对于背包问题，其实递推公式算是容易的，难是难在遍历顺序上，如果把遍历顺序搞透，才算是真正理解了。

### 背包问题总结
![背包问题总结](../../images/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.jpeg)