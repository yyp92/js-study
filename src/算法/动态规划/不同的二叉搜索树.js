/**
 * 不同的二叉搜索树
 * https://leetcode.cn/problems/unique-binary-search-trees/
 * 
 * 题意：
 *  给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
 * 
 * 示例：
 *  输入： 3
 *  输出： 5
 *  结果：
 *     1          3      3       2      1
 *      \        /      /       / \      \
 *       3      2      1       1   3      2
 *      /      /        \                  \
 *     2      1          2                  3
 * 
 * 思路：
 *  了解了二叉搜索树之后，我们应该先举几个例子，画画图，看看有没有什么规律。
 *  n为1的时候有一棵树，n为2有两棵树，这个是很直观的。
 *  来看看n为3的时候，有哪几种情况。
 *      当1为头结点的时候，其右子树有两个节点，看这两个节点的布局，是不是和 n 为2的时候两棵树的布局是一样的啊！
 *      （可能有同学问了，这布局不一样啊，节点数值都不一样。别忘了我们就是求不同树的数量，并不用把搜索树都列出来，所以不用关心其具体数值的差异）
 *      当3为头结点的时候，其左子树有两个节点，看这两个节点的布局，是不是和n为2的时候两棵树的布局也是一样的啊！
 *      当2为头结点的时候，其左右子树都只有一个节点，布局是不是和n为1的时候只有一棵树的布局也是一样的啊！
 *  发现到这里，其实我们就找到了重叠子问题了，其实也就是发现可以通过dp[1] 和 dp[2] 来推导出来dp[3]的某种方式。
 * 
 *  思考到这里，这道题目就有眉目了。
 *      dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量
 *      元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量
 *      元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量
 *      元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量
 *      有2个元素的搜索树数量就是dp[2]。
 *      有1个元素的搜索树数量就是dp[1]。
 *      有0个元素的搜索树数量就是dp[0]。
 *      所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]。
 * 
 * 动规五部曲:
 *  1.确定dp数组（dp table）以及下标的含义
 *      dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]。
 *      也可以理解是i的不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。
 *      以下分析如果想不清楚，就来回想一下dp[i]的定义
 *  2.确定递推公式
 *      在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]
 *      j相当于是头结点的元素，从1遍历到i为止。
 *      所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量
 *  3.dp数组如何初始化
 *      初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。
 *      那么dp[0]应该是多少呢？
 *      从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。
 *      从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。
 *      所以初始化dp[0] = 1
 *  4.确定遍历顺序
 *      首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。
 *      那么遍历i里面每一个数作为头结点的状态，用j来遍历。
 *  5.举例推导dp数组
 *      n为5时候的dp数组状态如图：
 *          0 -> 1, 1 -> 1, 2 -> 2, 3 -> 5, 4 -> 14, 5 -> 42
 * 
 * 复杂度：
 *  时间复杂度：$O(n^2)$
 *  空间复杂度：$O(n)$
 * 
 * 总结：
 *  这道题目虽然在力扣上标记是中等难度，但可以算是困难了！
 *  首先这道题想到用动规的方法来解决，就不太好想，需要举例，画图，分析，才能找到递推的关系。
 *  然后难点就是确定递推公式了，如果把递推公式想清楚了，遍历顺序和初始化，就是自然而然的事情了。
 *  可以看出我依然还是用动规五部曲来进行分析，会把题目的方方面面都覆盖到！
 */
const numTrees = (n) => {
    let dp = new Array(n+1).fill(0);
    dp[0] = 1;
    dp[1] = 1;

    for (let i = 2; i <= n; i++) {
        for (let j = 1; j <= i; j++) {
            dp[i] += dp[j-1] * dp[i-j];
        }
    }

    return dp[n];
};


// 测试
console.log(numTrees(0))
console.log(numTrees(1))
console.log(numTrees(2))
console.log(numTrees(3))
console.log(numTrees(4))
console.log(numTrees(5))